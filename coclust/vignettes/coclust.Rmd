---
title: "Co-clustering example"
author: "David Beley, Boubacar Sow"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Co-clustering example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Dans ce rapport nous présentons notre paquet R **coclust**, permettant d'effectuer un co-clustering gaussien à modèle de blocs latents. 

## Préparation de l'environnement

```{r}
library(coclust)
library(blockcluster)
library(printr)
data("gaussiandata")
```

**coclust** est notre paquet, implémentant un co-clustering gaussien à blocs latent.

**blockcluster** est le paquet de co-clustering qui servira de comparaison.

**printr** est un paquet permettant l'impression des pages d'aide dans un rapport rmarkdown.

# Paquet coclust

Notre paquet contient trois fonctions :
  * lbvem
  * icl
  * plot_coclust
Dans les lignes qui suivent, nous décrivons l'utilisation de chacune de ces trois fonctions. 
## Fonction lbvem

```{r, echo=FALSE, results='asis'}
help(lbvem)
```

## Fonction icl

```{r, echo=FALSE, results='asis'}
help(icl)
```

## Fonction plot_coclust

```{r, echo=FALSE, results='asis'}
help(plot_coclust)
```

## Co-clustering

Nous effectuons un co-clustering avec la fonction lbvem sur les données gaussiandata du package blockcluster.

```{r}
res <- lbvem(gaussiandata, nbcoclust = c(3, 2), init = 50)
```

Notre fonction lbvem effectue un co-clustering gaussien à modèle latent par blocs. Pour trouver les paramètres de la log-likelihood, nous avons implémenté l'algorithme VEM (Variational Expected Maximisation). Nous avons également implémenté le critère de convergence ICL (Integrated Completed Likelihood), il permet de choisir le modèle pertinent, et le nombre de composantes du modèle de mélange gaussien. 

Pour le critère de convergence  de lbvem nous avons utilisé deux méthodes :
  * pour sortir de l'algorithme VEM nous vérifions que les matrices des Paramètres estimés (moyennes et ecart-types) ne se modifie plus (écart entre l'ancienne matrice et la nouvelle < 0.1)
  * nous répéterons jusqu'à ce que le critère ICL ne bouge plus (écart entre l'ancien et le nouveau < 1) ou ne décroît plus

L'initialisation de lbvem s'est faite avec kmeans clustering par lignes et colonnes. Le nombre de clusters de départ a été choisi de manière arbitraire. 

Pour les jeux de données que nous avons testés, nous observons que dans certains cas, nous n'obtenons pas le même nombre clusters  initiales et finales, les clusters se vident.

## ICL
```{r}
res$icl
```


## Représentation graphique

```{r fig.height = 6, fig.width = 8, fig.align = "center"}
plot_coclust(res)
```

Sur le graphique ci dessus, à gauche sont représentées les données originales, à droite on affiche les données avec le partitionnement trouvé par notre algorithme (lbvem) de co-clustering.


# Blockcluster package
## Co-clustering
Ici on fait un co-clustering de 3 groupes en lignes et 2 groupes en colonnes en utilisant le parkage blockbluster, 
```{r}
out <- coclusterContinuous(as.matrix(gaussiandata), nbcocluster = c(3, 2))
```

## ICL
```{r}
summary(out)
```

Dans les résultats ci-dessus, on retrouve une valeur de l'ICL proche de la valeur trouvée par notre fonction.

## Représentation graphique
```{r fig.height = 6, fig.width = 8, fig.align = "center"}
plot(out)
```

# Test sur les données iris

## Préparation des données
```{r}
iris2 <- subset(iris, select=-Species)
```


## Co-clustering
```{r}
res_iris <- lbvem(iris2, c(3, 2), 50)
plot_coclust(res_iris)
```


## ICL
```{r}
res_iris$icl
```

## Représentation graphique
```{r fig.height = 6, fig.width = 8, fig.align = "center"}
plot_coclust(res_iris)
```

